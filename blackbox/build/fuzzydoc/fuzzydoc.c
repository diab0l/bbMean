/*----------------------------------------------------------------------------

  Fuzzydoc v0.1 - Copyright @ 2009 grischka@users.sourceforge.net

  Fuzzydoc is free software, released under the GNU General Public
  License (GPL version 2). For details see:

  http://www.fsf.org/licenses/gpl.html

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  --------------------------------------------------------------------------*/

#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int bool;
#define false 0
#define true 1

struct line_node
{
    struct line_node *next;
    int type;
    int chapter;
    int flags;
    int indent;
    int t1,t2,t3;
    char *topic_ref;
    int org_topic_length;
    char *text;
};

#define _topic_ "%s"

struct value_node
{
    struct value_node *next;
    char *key;
    char *val;
};

enum
{
    IS_H1 = 1,
    IS_H2 = 2,
    IS_H3 = 3,
    IS_H4 = 4,

    IS_HR   ,

    IS_P    ,
    IS_LI   ,
    IS_TAB  ,
    IS_PRE  ,
    IS_DEF  ,
    IS_QUOT ,
    IS_NEWLINE ,

    IS_TOC  ,
};

char basename[80];
char exepath[300];
bool put_toc;
bool cvt_amp;
char *argv0;

struct line_node *lines;
struct value_node *v_nodes;

const char *file_base;
const char *file_ext;

// #define LINE_SIZE 4000
#define LINE_SIZE 16000
#define TABC ' '

bool numbers;
bool framed_mode;
bool no_escape;
int toc_mode;
int chapter_count;
int g_indent;

#define TOC_PARA  0
#define TOC_LINES 1
#define TOC_LIST  2

const char default_template[] =
    "<HTML><HEAD>"
    "\n<TITLE>$(title)</TITLE>"
    "\n<STYLE type=text/css>"
    "\n$(include cssfile) $(styles)"
    "\n</STYLE>"
    "\n</HEAD>"
    "\n<BODY>"
    "\n<H1 class=\"toc\">$(header)</H1>"
    //"\n$(toc)"
    "\n$(body)"
    "\n<P>&nbsp;</P>"
    "\n<P class=\"footer\">$(footer)</P>"
    "\n<HR/>"
    "\n<P>Html generated by fuzzydoc 0.1</P>"
    "\n</BODY></html>"
    ;

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Some list stuff */

#define m_free free
#define m_alloc malloc
#define c_alloc(n) calloc(1,n)

#define dolist(_e,_l) for (_e=_l;_e;_e=_e->next)

typedef struct list_node { struct list_node *next; void *v; } list_node ;
typedef struct string_node { struct string_node *next; char str[1]; } string_node;

void freeall(void *p)
{   list_node *s, *q;
    q=*(list_node**)p;
    for ( ; q; q=(s=q)->next, m_free(s));
    *(list_node**)p=q;
}

void reverse_list (void *d)
{   list_node *a, *b, *c;
    a=*(list_node**)d;
    for (b=NULL; a; c=a->next, a->next=b, b=a, a=c);
    *(list_node**)d=b;
}

void cons_node (void *a0, const void *e0)
{
    list_node *a = (list_node*)a0, *e = (list_node*)e0;
    e->next = a->next; a->next = e;
}

void append_node (void *a0, const void *e0)
{
    list_node *a = (list_node*)a0, *e = (list_node*)e0;
    for ( ;a->next;a=a->next);
    a->next=e; e->next=NULL;
}

int listlen(const void *v0)
{
    list_node *v = (list_node*)v0; int i = 0;
    while(v) i++, v=v->next;
    return i;
}

void *nth_node (const void *v0, int n)
{
    list_node *v = (list_node*)v0;
    while (n && v)  n--, v = v->next;
    return v;
}

char *new_str(const char *s) {
    return s ? strcpy((char*)m_alloc(strlen(s)+1), s) : NULL;
}

void free_str(const char **s){
    if (*s) m_free((void*)*s), *s=NULL;
}

char *extract_string(char *d, const char *s, int n)
{
    memcpy(d, s, n); d[n] = 0; return d;
}

struct string_node *new_string_node(const char *s)
{
    struct string_node *b;
    b = (struct string_node *)m_alloc(sizeof *b + strlen(s));
    strcpy(b->str, s);
    b->next = NULL;
    return b;
};

/*----------------------------------------------------------------------------*/
#ifndef _WIN32
/*----------------------------------------------------------------------------*/

#define lower_char(c) ((c)>='A' && (c)<='Z' ? (c)+32 : c)
#define upper_char(c) ((c)>='a' && (c)<='z' ? (c)-32 : c)

int stricmp(const char *a, const char *b)
{
    for (;;++a, ++b) {
        int c = *a, d = *b;
        if (c != d) {
            c = lower_char(c), d = lower_char(d);
            if (c != d)
                return c - d;
        }
        if (c == 0)
            return 0;
    }
}

int memicmp(const void *a, const void *b, unsigned n)
{
    for (;n; ++a, ++b, --n) {
        int c = *(unsigned char*)a;
        int d = *(unsigned char*)b;
        if (c != d) {
            c = lower_char(c), d = lower_char(d);
            if (c != d)
                return c - d;
        }
    }
    return 0;
}

char *strlwr(char *p)
{
    char *a; int c, d;
    for (a = p; 0 != (c = *a); ++a)
        if (c != (d = lower_char(c))) *a = d;
    return p;
}

char *strupr(char *p)
{
    char *a; int c, d;
    for (a = p; 0 != (c = *a); ++a)
        if (c != (d = upper_char(c))) *a = d;
    return p;
}

char *gui_setmypath(char *path, const char *filename)
{
    int nLen;
    nLen = strlen(strcpy(path, argv0));
    while (nLen && path[nLen-1] != '/')
        nLen--;
    if (filename && *filename) {
        strcpy(path+nLen, filename);
    } else {
        if (nLen > 0 && (nLen == 1 || path[nLen-2] != ':'))
            --nLen;
        path[nLen] = 0;
    }
    return path;
}

/*----------------------------------------------------------------------------*/
#else
/*----------------------------------------------------------------------------*/
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
char *gui_setmypath(char *path, const char *filename)
{
    int nLen;
    nLen = GetModuleFileName(NULL, path, MAX_PATH);
    while (nLen && path[nLen-1] != '\\')
        nLen--;
    if (filename && *filename) {
        strcpy(path+nLen, filename);
    } else {
        if (nLen > 0 && (nLen == 1 || path[nLen-2] != ':'))
            --nLen;
        path[nLen] = 0;
    }
    return path;
}

/*----------------------------------------------------------------------------*/
#endif
/*----------------------------------------------------------------------------*/

FILE *fopen_config(const char *file)
{
    FILE *fp = fopen(file, "rb");
    if (NULL == fp)
    {
        char path[300];
        gui_setmypath(path, file);
        fp = fopen(path, "rb");
    }
    return fp;
}

void add_extension(char *buffer, const char *ext, bool force)
{
    char *a, *p, *e;
    a = buffer;
    p = strrchr(a, '\\');
    if (NULL == p)
        p = strrchr(a, '/');
    if (p)
        p++;
    else
        p = a;
    e = strrchr(p, '.');
    if (NULL == e)
        e = strchr(p, 0);
    else
    if (false == force)
        return;
    strcpy(e, ext);
}

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Utilities */

void set_val(const char *key, const char *val)
{
    struct value_node *v;
    dolist (v, v_nodes)
        if (0 == strcmp(key, v->key))
        {
            m_free(v->val);
            break;
        }

    if (NULL == v)
    {
        v = (struct value_node *)m_alloc(sizeof *v);
        v->key = new_str(key);
        cons_node(&v_nodes, v);
    }

    v->val = new_str(val);
    /*printf("key <%s> <%s>\n", key, val); */
}

void skip_spc(char const **p)
{
    while (**p == ' ' || **p == '\t') (*p)++;
}

void parse_key(const char *s)
{
    char key[80], *d = key; const char *p = s;
    skip_spc(&p);
    while ((unsigned char)*p > ' ' && *p != '=') *d++ = *p++;
    *d = 0;
    skip_spc(&p);
    if (*p == '=')
    {
        p++;
        skip_spc(&p);
        set_val(key, p);
    }
}

const char *get_val(const char *key, const char *def)
{
    struct value_node *v;
    dolist (v, v_nodes)
        if (0 == strcmp(key, v->key))
            return v->val;

    return def;
}

void set_default_val(const char *key, const char *val)
{
    if (NULL == get_val(key, NULL)) set_val(key, val);
}

bool is_link (const char *s)
{
    return strlen(s) > 7 && (
        0 == memcmp(s, "http://", 7)
        || 0 == memcmp(s, "mailto:", 7)
        );
}


int detab(char* p, char *q, int n, int k) {
    int i, r; char c;
    for (r=i=0;n;)
    {
        c=*q++ ,n--;
        if (c==13) continue;
        if (c==0) break;
        i++;
        if (c==10) i=0;
        if (c==9)
        {
            c=TABC;
            if (i%k) n++, q--;
            if (k<2) c=32;
        }
        if (p) *p++=c;
        r++;
    }
    return r;
}

void replace_blanks(char *s)
{
    while (NULL != (s = strchr(s, ' ')))
        *s = '_';
}

int is_table_row(const char *s)
{
    const char *p = s;
    int r = 0;
    while (NULL != (p = strchr(p, ':')))
    {
        p++;
        if (' '== *p || 0 == *p) r++;
    }
    return r;
}


int is_table_header(const char *s)
{
    int r, n = strlen(s);
    if (0 == n || s[n-1] != ':')
        return 0;

    r = is_table_row(s);
    return r >= 2 ? r : 0;
}

void free_line(struct line_node **pl)
{
    struct line_node *l = *pl;
    *pl = l->next;
    m_free(l->text);
    if (l->topic_ref) m_free(l->topic_ref);
    m_free(l);
}


char *make_url(char *buffer, const char *s)
{
    char c, *d = buffer;
    do
    {
        c = *s++;
        if ((c >= 'a' && c <= 'z')
         || (c >= 'A' && c <= 'Z')
         || (c >= '0' && c <= '9')
         || c == '_'
         || c == '-'
         || c == 0)
            ;
        else
        if (c == ' ' || c == '/' || c == '&' || c == '?')
            c = '_';
        else
        if (c == '\\')
            c = *s++;
        else
        {
            d += sprintf(d, "%%%02X", c);
            continue;
        }

        *d ++ = c;

    } while (c);
    return buffer;
}

void make_topic_str(struct line_node *line, struct line_node *lines, char *s)
{
    struct line_node *l; int n = 0; int k;
    char buffer[LINE_SIZE];

    k = strlen(make_url(buffer, s));

    for (l = lines; l != line; l = l->next)
        if (l->topic_ref
         && l->chapter == line->chapter
         && l->org_topic_length == k
         && 0 == memicmp(l->topic_ref, buffer, k)
         )
            ++n;

    if (n) sprintf(buffer + k, "_%d", n+1);
    line->org_topic_length = k;
    line->topic_ref = new_str(buffer);
}

const char *get_chapter_url(int chapter)
{
    char temp[100];
    sprintf(temp, "chapter-%d", chapter);
    return get_val(temp, "null");
}


/*----------------------------------------------------------------------------*/
bool is_internal_link(const char *s, char *d)
{
    char buffer[LINE_SIZE];
    int level = 0;
    struct line_node *l;

    replace_blanks(strcpy(buffer, s));
    dolist (l, lines)
    {
        int h = l->type;
        if (h < IS_H1 || h > IS_H3)
            continue;

        if (0 != strcmp(buffer, l->text))
        {
            level = h;
            continue;
        }

        if (framed_mode)
        {
            if (IS_H1 == h || 0 == level)
                sprintf(d, "%s_%s%s", file_base, get_chapter_url(l->chapter), file_ext);
            else
                sprintf(d, "%s_%s%s#"_topic_"", file_base, get_chapter_url(l->chapter), file_ext, l->topic_ref);
        }
        else
        {
            sprintf(d, "#"_topic_"", l->topic_ref);
        }
        return true;
    }
    return false;
}

/*----------------------------------------------------------------------------*/
/* Encode htmp entities, also scan for embedded links. */

void encode_line(char *d, const char *s, bool pre, bool header)
{
    unsigned char c;
    char *p = NULL;
    char *b = NULL;
    char *x = NULL;
    char buffer_1[LINE_SIZE];
    char buffer_2[LINE_SIZE];
    char buffer_3[LINE_SIZE];

    static const char link_template_body[] =
        "<A HREF=\"%s\">%s</A>"
        ;

    static const char link_template_frame[] =
        "<A HREF=\"%s\" target=\"_parent\">%s</A>"
        ;

    static const char figure_template[] =
        "<IMG SRC=\"%s\"/>"
        ;

    const char * link_template = framed_mode
        ? link_template_frame
        : link_template_body
        ;

    if (false == pre) skip_spc((const char**)&s);

    do
    {
        const char *extra = NULL;
        c = *s++;

        if (c == ' ') { x = p, p = NULL; }
        else
        if (NULL == p) p = d;

        /* expand special html characters */
        if (c == '<' && pre) extra = "&lt;";
        else
        if (c == '>') extra = "&gt;";
        else
        if (c == '&' && cvt_amp) extra = "&amp;";
        else
        if (c == '\"') extra = "&quot;";
        else
        if (c == 0xa9) extra = "&copy;";
        else
        if (false == pre)
        {
            if (c == '-' && 0 == memcmp(s-1, "-> '", 4))
            {
                /* internal link: -> 'That chapter'. */
                const char *a = s + 3;
                const char *e = strchr(a, '\'');
                if (e)
                {
                    extract_string(buffer_3, a, e-a);
                    encode_line(buffer_1, buffer_3, pre, 0);
                    if (is_internal_link(buffer_1, buffer_2))
                    {
                        memcpy(d, s-1, 3); d+=3;
                        d += sprintf(d, link_template_body, buffer_2, buffer_1);
                        s = e+1;
                        continue;
                    }
                }
            }
            else
            if (c == '(' && x && d == p && 0 == memicmp(s, "See '", 5))
            {
                /* internal link: (See 'That chapter'). */
                const char *a = s + 5;
                const char *e = strstr(a, "')");
                if (e)
                {
                    extract_string(buffer_3, a, e-a);
                    encode_line(buffer_1, buffer_3, pre, 0);
                    if (is_internal_link(buffer_1, buffer_2))
                    {
                        const char *y = p;
                        while (y > x && ' ' == y[-1]) --y;
                        extract_string(buffer_1, x, y - x);
                        d = x + sprintf(x, link_template_body, buffer_2, buffer_1);
                        s = e+2;
                        continue;
                    }
                }
            }
            else
            if (c == '<')
            {
                char *e = strchr(s, '>');
                if (e)
                {
                    extract_string(buffer_3, s, e-s);

                    if (buffer_3[0] == '$')
                        encode_line(buffer_2, buffer_3, pre, 0);
                    else
                        strcpy(buffer_2, buffer_3);

                    if (p && p < d)
                        extract_string(buffer_1, p, d-p);
                    else
                        strcpy(buffer_1, buffer_2);

                    if (is_link(buffer_2)
                        || 0 == memcmp(buffer_2, "./", 2)
                        || 0 == memcmp(buffer_2, "../", 3)
                        )
                    {
                        int n = sprintf(p, link_template, buffer_2, buffer_1);
                        d = p+n;
                        s = e+1;
                        continue;
                    }
                    else
                    if (is_internal_link(buffer_2, buffer_2))
                    {
                        int n = sprintf(p, link_template_body, buffer_2, buffer_1);
                        d = p+n;
                        s = e+1;
                        continue;
                    }
                }
                extra = "&lt;";
            }
            else
            if (c == '_' && (0 == no_escape || header))
                extra = "&nbsp;";
            else
            if (c == '*')
            {
                if (NULL == b)
                {
                    b = d;
                }
                else
                {
                    memmove(b+2, b, d - b);
                    d += 2;
                    memcpy(b, "<B>", 3);
                    b = NULL;
                    extra = "</B>";
                }
            }
            else
            if (c == '\\' && ('<' == *s || '_' == *s || ':' == *s) && 0 == no_escape)
                c = *s++;
            else
            if (is_link(s-1))
            {
                const char *e, *p; int n;
                e = --s;
                while (*e && *e != ' ')
                    ++e;
                while (e > s && (e[-1] == ',' || e[-1] == ';' || e[-1] == '.' || e[-1] == ')'))
                    --e;
                p = extract_string(buffer_2, s, e-s);

                if (0 == memicmp(p, "mailto:", 7))
                    p += 7;
            /*
                else
                if (0 == memicmp(p, "http://", 7)) p += 7;
             */

                strcpy(buffer_1, p);

                n = sprintf(d, link_template, buffer_2, buffer_1);
                d += n;
                s = e;
                continue;
            }
            else
            if (c == '[' && 0 == memicmp(s, "Figure ", 7))
            {
                const char *e, *f; int n;
                s += 6; while (' ' == *++s);
                e = strchr(s, ']');
                if (NULL == e) e = strchr(s, 0);
                f = strchr(s, ':');
                if (NULL == f || f > e) f = e;
                extract_string(buffer_2, s, f-s);
                n = sprintf(d, figure_template, buffer_2);
                d += n;
                s = e; if (*s) s++;
                continue;
            }
            else
            if (c == '$' && '(' == *s)
            {
                const char *e = strchr(s, ')');
                if (e)
                {
                    extract_string(buffer_1, s+1, e-s-1);
                    extra = get_val(buffer_1, NULL);
                    if (extra) s = e+1;
                }
            }
        }

        if (extra)
        {
            int n = strlen(extra);
            memcpy(d, extra, n);
            d += n;
        }
        else
        {
            *d++ = c;
        }

    } while (c);
}

/*----------------------------------------------------------------------------*/
char *topic_number(struct line_node *l, char *number_buffer)
{
    const char *fmt = "";

    int y, t1, t2, t3;
    t1 = t2 = t3 = 0;

    if (numbers)
    {
        t1 = l->t1, t2 = l->t2, t3 = l->t3, y = l->type;
        if (0 == t1)
        {
            t1 = t2, t2 = t3, --y;
            if (0 == t1)
                t1 = t2, --y;
        }

        if (y == IS_H1)
            fmt = "%d.&nbsp;";
        else
        if (y == IS_H2)
            fmt = "%d.%d&nbsp;";
        else
        if (y == IS_H3)
            fmt = "%d.%d.%d&nbsp;";
    }
    sprintf(number_buffer, fmt, t1, t2, t3);
    return number_buffer;
}

/*----------------------------------------------------------------------------*/
/* Print out a part of a table */

int print_table_row(FILE *op, const char *s, int cols)
{
    char raw_buffer[LINE_SIZE];
    char buffer[LINE_SIZE];
    char key[80];

    bool first = 0 == cols;
    int column = 0;
    const char *p, *e, *tag, *tw;

    while (*s)
    {
        p = s;
        ++ column;
        for (;;)
        {
            if ((column == cols && false == first)
                || NULL == (e = strchr(p, ':')))
            {
                e = p = strchr(p, 0);
                break;
            }
            p = e + 1;

            if (e == s || e[-1] == '\\')
                continue;

            if (' ' == *p || 0 == *p)
                break;
        }

        while (e > s && e[-1] == ' ') e--;
        while (s < e && s[0] == ' ') s++;

        extract_string(raw_buffer, s, e-s);
        encode_line(buffer, raw_buffer, false, 0);

        if (0 == *buffer)
            strcpy(buffer, "&nbsp;");

        tag = first ? "TH" : "TD";
        sprintf(key, "table-column-width-%d", column);
        tw = get_val(key, column==1 ? "30%" : NULL);

        if (1 == column) fprintf(op, "<TR ALIGN=LEFT>");

        if (tw)
            fprintf(op, "<%s WIDTH=%s>%s</%s>\n", tag, tw, buffer, tag);
        else
            fprintf(op, "<%s>%s</%s>\n", tag, buffer, tag);

        s = p;
    }
    if (column) fprintf(op, "</TR>\n");
    return column;
}

/*----------------------------------------------------------------------------*/
/* Print out Table of Contents */

void print_toc(FILE *op, struct line_node *lines)
{
    char buffer[LINE_SIZE];
    char number_buffer[LINE_SIZE];
    int h, level, base_level;
    struct line_node *l;

    base_level = level = chapter_count <= 1 ? 1 : 0;

    dolist (l, lines)
    {
        h = l->type;
        if (h < IS_H1 || h > IS_H3)
            continue;

        encode_line(buffer, l->text, false, 1);

        if (level > base_level)
            fprintf(op, "\n");

        if (toc_mode == TOC_LIST) {
            int l = level;
            while (h < l)
                fprintf(op, "</UL>\n"), --l;
            while (h > l)
                fprintf(op, "<UL>\n", ++l);
            fprintf(op, "<LI>");
        }

        if (toc_mode == TOC_LINES)
            fprintf(op, "<P CLASS=\"T%d\">", h);

        fprintf(op, "<A CLASS=\"T%d\" HREF=\"", h);
        {
            if (framed_mode)
            {
                if (IS_H1 == h || 0 == level)
                    fprintf(op, "%s_%s%s", file_base, get_chapter_url(l->chapter), file_ext);
                else
                    fprintf(op, "%s_%s%s#"_topic_"", file_base, get_chapter_url(l->chapter), file_ext, l->topic_ref);
            }
            else
            {
                fprintf(op, "#"_topic_"", l->topic_ref);
            }
        }

        fprintf(op, "\">%s%s</A>", topic_number(l, number_buffer), buffer);

        if (toc_mode == TOC_PARA)
            fprintf(op, " &nbsp; ");
        level = h;

        if (toc_mode == TOC_LINES)
            fprintf(op, "</P>");

    }

    if (toc_mode == TOC_LIST)
        while (level > base_level)
            fprintf(op, "\n</UL>"), --level;

    put_toc = false;
}

/*----------------------------------------------------------------------------*/
/* Print out a body file, either non-framed (chapter=0) or framed (chapter=1...) */

void print_body(FILE *op, struct line_node *lines, int chapter)
{
    char buffer[LINE_SIZE];
    char number_buffer[80];
    int last_flag = 0;
    struct line_node *l;


    dolist(l, lines)
    {
        if (chapter != l->chapter && chapter) continue;
        if (0 == l->type) continue;

        switch (l->type)
        {
            case IS_H1:
            case IS_H2:
            case IS_H3:
                encode_line(buffer, l->text, false, 1);
                fprintf(op,
                    "<A CLASS=\"label\" NAME=\""_topic_"\">"
                    "<H%d>%s%s</H%d></A>\n",
                    l->topic_ref,
                    l->type,
                    topic_number(l, number_buffer),
                    buffer,
                    l->type);
                break;

            case IS_H4:
                encode_line(buffer, l->text, false, 1);
                fprintf(op, "<H4>%s</H4>\n", buffer);
                break;

            case IS_HR:
                fprintf(op, "<HR>\n");
                break;

            case IS_TAB:
            {
                int n;
                if (IS_TAB == last_flag) fprintf(op, "<BR/>&nbsp;\n");
                fprintf(op, "%s", get_val("table-start", "<TABLE width=100%>"));
                n = print_table_row(op, l->text, 0);
                while (l->next && l->next->type == IS_TAB)
                {
                    l = l->next;
                    print_table_row(op, l->text, n);
                }
                fprintf(op, "</TABLE>\n");
                break;
            }

            case IS_LI:
            {
                const char *tag = l->flags ? "OL" : "UL";
                encode_line(buffer, l->text, false, 0);
                fprintf(op, "<%s><LI>%s", tag, buffer);
                while (l->next && l->next->type == IS_LI && l->next->flags == l->flags)
                {
                    l = l->next;
                    encode_line(buffer, l->text, false, 0);
                    fprintf(op, "\n<LI>%s", buffer);
                }
                fprintf(op, "</%s>\n", tag);
                break;
            }

            case IS_PRE:
            {
                struct line_node *a = l, *b = NULL;
                do {
                    if (a->type == IS_PRE) b = a->next;
                    else
                    if (a->text[0]) break;
                    a = a->next;
                } while (a);

                encode_line(buffer, l->text, true, 0);
                fprintf(op, "<PRE>%s", buffer);
                while (l->next && l->next != b)
                {
                    l = l->next;
                    encode_line(buffer, l->text, true, 0);
                    fprintf(op, "\n%s", buffer);
                }
                fprintf(op, "\n</PRE>\n");
                break;
            }

            case IS_P:
            {
                encode_line(buffer, l->text, false, 0);
                fprintf(op, "<P>%s", buffer);
                while (l->next && l->next->type == IS_P)
                {
                    int f = l->flags;
                    l = l->next;
                    encode_line(buffer, l->text, false, 0);
                    if (f)
                        fprintf(op, "\n<BR />%s", buffer);
                    else
                        fprintf(op, "\n%s", buffer);
                }
                fprintf(op, "</P>\n");
                break;
            }

            case IS_DEF:
            {
                encode_line(buffer, l->text, false, 0);
                fprintf(op, "<DL><DT>%s</DT>", buffer);
                while (l->next && l->next->type == IS_DEF)
                {
                    l = l->next;
                    encode_line(buffer, l->text, false, 0);
                    if (l->flags == 0)
                    {
                        fprintf(op, "\n<DT>%s</DT>", buffer);
                    }
                    else
                    {
                        fprintf(op, "\n<DD>%s</DD>", buffer);
                    }
                }
                fprintf(op, "</DL>\n");
                break;
            }

            case IS_QUOT:
            {
                encode_line(buffer, l->text, false, 0);
                fprintf(op, "<BLOCKQUOTE>%s</BLOCKQUOTE>\n", buffer);
                break;
            }

            case IS_NEWLINE:
            {
                fprintf(op, "<P>&nbsp;</P>\n");
                break;
            }

            case IS_TOC:
            {
                if (l->flags)
                {
                    if (false == put_toc)
                        break;
                    fprintf(op, "<H2>Contents</H2>\n");
                }
                print_toc(op, lines);
                break;
            }
        }

        last_flag = l->type;
    }
}

/*----------------------------------------------------------------------------*/
void join_lines(struct line_node *last, bool same_indent)
{
    struct line_node *l;

    int indent = last->indent;
    if (false == same_indent)
        indent ++;

    while (NULL != (l = last->next) && l->indent >= indent)
    {
        char *cp = l->text + l->indent - 1;
        int n1 = strlen(last->text);
        int n2 = strlen(cp);
        char *s = (char*)m_alloc(n1 + n2 + 2);
        memcpy(s, last->text, n1);
        s[n1] = '\n';
        memcpy(s + n1 + 1, cp, n2);
        s[n1 + n2 + 1] = 0;
        m_free(last->text);
        last -> text = s;
        free_line(&last->next);
    }
}

/* ------------------------------------- */
/* check for header definition */
int is_header (char *text)
{
    char c, *p; int h;
    for (p = text; ' '== *p;  ++p);
    c = *p;

    if ('+' == c || '~' == c || '_' == c)
        h = IS_HR;
    else if (p != text) return 0;
    else if ('*' == c) h = IS_H1;
    else if ('=' == c) h = IS_H2;
    else if ('-' == c) h = IS_H3;
    else if ('.' == c) h = IS_H4;
    else return 0;

    if (c == text[1] && c == text[2] && c == text[3])
        return h;
    return 0;
}

/*----------------------------------------------------------------------------*/
/* Run through lines and see what it all means. */

int set_flags(struct line_node *lines)
{
    int chapter = 0;
    int h, n;

    bool first_chapter = true;
    bool insert_toc = true;

    struct line_node *first_empty = NULL;
    struct line_node *l;

    /* calculate indentation */
    dolist (l, lines)
    {
        char * cp = l->text;
        while (' '== *cp)
            cp++;

        l->indent = cp - l->text;
    }


    dolist (l, lines)
    {
        char c, ci, *si;
        l->chapter = chapter ? chapter : 1;

        /* get the first character */
        c = l->text[0];
        si = l->text + l->indent;
        ci = *si;

        /* ------------------------------------- */
        /* empty line */
        if (0 == c)
        {
            first_empty = l;
            l -> type = 0;
            continue;
        }

        /* ------------------------------------- */
        /* pre formatted */
        if (l->indent + g_indent >= 4)
        {
            n = l->indent;
            if (n > 4) n = 4;
            strcpy(l->text, l->text + n);
            l->indent -= n;
            l -> type = IS_PRE;
            continue;
        }

        /* ------------------------------------- */
        /* horizontal rule */
        h = is_header(si);
        if (h)
        {
            if (IS_HR == h)
            {
                l -> type = IS_HR;
            }
            continue;
        }

        /* ------------------------------------- */
        /* quotation */
        if (l->indent && '\"' == ci)
        {
            l->type = IS_QUOT;
            join_lines(l, true);
            continue;
        }

        /* ------------------------------------- */
        /* bulleted list */

        if (('-' == ci || '+' == ci || '*' == ci || '~' == ci)
            && ' ' == si[1])
        {
            strcpy(si, si+2);
            l -> type = IS_LI;
            join_lines(l, false);
            continue;
        }

        /* ------------------------------------- */
        /* numbered list */
        if (ci >= '0' && ci <= '9'
            && (si[1] == '.' || si[1] == '-' || si[1] == ')')
            && si[2] == ' ')
        {
            const char *cp = si+2; while (' ' == *++cp);
            strcpy(si, cp);
            l -> flags = 1;
            l -> type = IS_LI;
            join_lines(l, false);
            continue;
        }

        /* ------------------------------------- */
        /* table first row */
        if (is_table_header(l->text))
        {
            l->type = IS_TAB;
            while (l->next && is_table_row(l->next->text))
            {
                l = l->next;
                l -> type = IS_TAB;
                join_lines(l, false);
            }
            continue;
        }

        /* ------------------------------------- */
        /* description */
        if (l->text[strlen(l->text)-1] == ':'
            && l->next
            && l->indent < l->next->indent)
        {
            //l->text[strlen(l->text)-1] = 0;
            l -> type = IS_DEF;
            for (;;)
            {
                l = l->next;
                l -> type = IS_DEF;
                l -> flags = 1;
                join_lines(l, true);
                break;
            /*
                k = l->next;
                if (NULL == k || k->text[0]) break;
                if (NULL == k->next || l->indent > k->next->indent)
                    break;
                free_line(&l->next);
            */
            }
            continue;
        }

        /* ------------------------------------- */
        /* special command */
        if ('[' == c && l->text[strlen(l->text)-1] == ']')
        {
            if (0 == strcmp(l->text, "[TOC]"))
            {
                l->type = IS_TOC;
                put_toc = false;
                continue;
            }
        }

        /* ------------------------------------- */
        /* check for header definition */
        if (l->next)
        {
            h = is_header(l->next->text + l->next->indent);

            if (h >= IS_H1 && h <= IS_H4)
            {

                if (IS_H1 == h && first_chapter)
                {
                    set_default_val("title", si);
                    set_default_val("header", si);
                    first_chapter = false;
                    l -> type = 0;
                    replace_blanks(si);
                }
                else
                {
                    replace_blanks(si);
                    if (IS_H1 == h || 0 == chapter)
                    {
                        ++chapter;
                    }

                    if (IS_H4 != h)
                    {
                        n = strlen(l->text);
                        if (':' == l->text[n-1]) l->text[n-1] = 0;

                        if (first_empty && insert_toc)
                        {
                            first_empty->flags = 1;
                            first_empty->type = IS_TOC;
                            insert_toc = false;
                        }
                    }
                    l -> type = h;
                    l -> chapter = chapter;
                    make_topic_str(l, lines, si);
                }

                if (IS_H1 == h)
                {
                    char buffer[100];
                    char url[100];

                    strlwr(strcpy(buffer, si));
                    make_url(url, buffer);
                    sprintf(buffer, "chapter-%d", l->chapter);
                    set_val(buffer, url);
                }

                l = l->next;
                continue;
            }
        }

        /* ------------------------------------- */
        /* else it must be a paragraph */

        l -> type = IS_P;
        l -> flags = l->indent >= 2;
        join_lines(l, false);
        continue;

    }

    /* more than two empty lines (three before header)
       insert a newline */
    h = 0;
    dolist (l, lines)
    {
        if (l && 0 == l->type && 0 == l->text[0])
            ++h;
        else
            h = 0;

        if (h > 1)
        {
            if (h > 2
             || (l->next &&
                  (l->next->type == 0 || l->next->type > IS_H4)))
                l -> type = IS_NEWLINE;
        }
    }

    /* set topic numbers, like 1.2.5 */
    {
        int t1 = 0, t2 = 0, t3 = 0;
        dolist (l, lines)
        {
            switch (l->type) {
            case IS_H1: ++t1, t2 = t3 = 0; break;
            case IS_H2: ++t2, t3 = 0; break;
            case IS_H3: ++t3; break;
            }
            l->t1=t1;
            l->t2=t2;
            l->t3=t3;
        }
    }

    return chapter;
}

/*----------------------------------------------------------------------------*/
/* Copy a Template to the output, replacing variables like "$(variable)" */

void copy_text_a(FILE *op, const char *file1, struct line_node *lines, int chapter);

void copy_line(FILE *op, const char *in, struct line_node *lines, int chapter)
{
    char buffer[LINE_SIZE];
    char *out = buffer;
    for (;;)
    {
        char c = *in++; char *e;
        if ('$' == c && '(' == *in && NULL != (e = strchr(in, ')')))
        {
            char label[80]; int insert; const char *v;

            in++;
            extract_string(label, in, e - in);
            if (label[0] && label[e - in -1] == ':') label[e - in - 1] = 0;

            in = e+1;
            insert = 0;
            if (0 == strcmp(label, "toc"))          insert = 1;
            else
            if (0 == strcmp(label, "body"))         insert = 2;
            else
            if (0 == memcmp(label, "include ", 8))  insert = 3;

            if (insert)
            {
                /* flush buffer */
                *out = 0; fprintf(op, "%s", buffer); out = buffer;
                switch(insert) {
                    case 1:
                        if (put_toc)
                            print_toc(op, lines);
                        break;
                    case 2:
                        print_body(op, lines, chapter);
                        break;
                    case 3:
                    {
                        const char *p = label+8;
                        p = get_val(p, p);
                        copy_text_a(op, p, lines, chapter);
                        break;
                    }
                }
                continue;
            }

            v = get_val(label, NULL);
            if (v)
            {
                int n = strlen(v);
                memcpy(out, v, n);
                out += n;
            }
            continue;
        }
        *out++ = c;
        if (0 == c) break;
    }
    fprintf(op, "%s\n", buffer);
}


void copy_text_a(FILE *op, const char *file1, struct line_node *lines, int chapter)
{
    FILE *fp; char line[LINE_SIZE];
    if (NULL == (fp = fopen_config (file1)))
        return;
    while (fgets(line, sizeof line, fp))
    {
        /* trim trailing stuff */
        char *se = strchr(line, '\0');
        while (se > line && (unsigned char)se[-1] <= 32) se--;
        *se = 0;
        copy_line(op, line, lines, chapter);
    }
    fclose(fp);
}

void copy_text(const char *file1, const char *file2, struct line_node *lines, int chapter)
{
    FILE *op;
    if (NULL == (op = fopen (file2, "wt"))) return;
    printf("<- writing %s\n", file2);
    if (NULL == file1)
        copy_line(op, default_template, lines, chapter);
    else
        copy_text_a(op, file1, lines, chapter);
    fclose(op);
}


/*----------------------------------------------------------------------------*/
/* Read the plain text, strip comments, handle includes and declarations */

char *trim_trailing(char *buffer)
{
    char *se = strchr(buffer, 0);
    /* trim trailing stuff */
    while (se > buffer && (unsigned char)se[-1] <= 32)
        se--;
    *se = 0;
    return se;
}

void read_lines(const char *path, struct line_node **plines)
{
    FILE *fp;
    bool in_comment = false;
    int indent = 1000;

    printf("-> reading %s", path);
    if (NULL == (fp = fopen (path, "rb")))
    {
        printf(" failed!\n");
        return;
    }
    printf("\n");

    for (;;)
    {
        char buffer[LINE_SIZE];
        char *se, *sa;
        int n;

        if (0 == fgets(buffer, sizeof buffer, fp))
            break;

        /* trim trailing stuff */
        se = trim_trailing(buffer);

        /* trim leading spaces */
        n = 0;
        sa = buffer;
        while (sa < se && n < indent && (unsigned char)sa[0] <= 32)
            sa++, n++;

        if (sa[0])
        {
            /* remove a global indentation */
            if (n < indent)
                indent = n;
            sa = buffer + indent;

            //printf("%d: %s\n", indent, sa);
        }

        n = se - sa;

        if (in_comment)
        {
            if (n >= 3 && sa[n-3] == '-'  && sa[n-2] == '-' && sa[n-1] == '>')
                in_comment = false;
            continue;
        }

        if (sa[0] == '/' && sa[1] == '/')
            continue;

        if (sa[0] == '<' && sa[1] == '!' && sa[2] == '-' && sa[3] == '-')
        {
            in_comment = true;
            continue;
        }

        if (sa[0] == '[' && ']' == sa[n-1])
        {
            if (0 == memicmp(sa, "[See ", 5))
            {
                sa[n-1] = 0;
                se = sa + 5;
                skip_spc((const char**)&se);
                read_lines(se, plines);
                continue;
            }

            if (0 == stricmp(sa, "[fuzzydoc]"))
            {
                sa = buffer;
                while (fgets(sa, sizeof buffer - (sa - buffer), fp))
                {
                    const char *pa = sa;
                    skip_spc(&pa);
                    strcpy(sa, pa);

                    se = trim_trailing(sa);

                    if (se > sa && se[-1] == '\\')
                    {
                        se[-1] = 0;
                        pa = sa;
                        sa = trim_trailing(sa);
                        if (pa > sa) *sa ++ = ' ';
                        continue;
                    }

                    sa = buffer;
                    if (sa[0] == '/' && sa[1] == '/')
                        continue;

                    if (0 == stricmp(sa, "[endfuzzy]"))
                        break;

                    //printf(":: %s\n", buffer);
                    parse_key(buffer);
                    continue;
                }
                continue;
            }
        }

        {
            char buffer[LINE_SIZE];
            struct line_node *l;

            n = detab(buffer, sa, n, 4);

            buffer[n] = 0;
            l = (struct line_node*)c_alloc(sizeof *l);
            l -> text = new_str(buffer);
            cons_node(plines, l);
            continue;
        }
    }
    fclose(fp);

    g_indent = indent;

}

/*----------------------------------------------------------------------------*/

char *make_template_name(char *buffer, const char *base, const char *suffix)
{
    char ext[80], *e;
    strcpy(buffer, base);
    add_extension(buffer, ".htm", false);
    e = strrchr(buffer, '.');

    strcpy(ext, e);
    strcpy(e, suffix);
    strcat(e, ext);
    return buffer;
}

char *make_output_name(char *buffer, int chapter)
{
    if (chapter > 0)
        sprintf(buffer, "%s_%s%s", file_base, get_chapter_url(chapter), file_ext);
    else
    if (chapter == 0)
        sprintf(buffer, "%s%s", file_base, file_ext);
    else
        sprintf(buffer, "%s_toc%s", file_base, file_ext);
    return buffer;
}

void set_auto_vars(struct line_node *lines, int chapter)
{
    char buffer[LINE_SIZE];
    struct line_node *l;
    dolist (l, lines)
        if (l->type == IS_H1 && l->chapter == chapter)
        {
            sprintf(buffer, ""_topic_"", l->topic_ref);
            set_val("chapter-anchor", buffer);
            set_val("chapter-name", l->text);
            break;
        }
}

/*----------------------------------------------------------------------------*/
/* Here is where it all starts. */

int main (int argc, char *argv[])
{
    char output_file[256];
    char tpl_file[256];
    char line[LINE_SIZE];
    char *a, *p;
    FILE *fp;
    const char *tm;

    printf("Fuzzydoc 0.1 - Copyright 2009 grischka\n");
    if (argc<2)
    {
        printf("Use: fuzzydoc <inputfile.txt>\n");
        return 1;
    }

    /*--------------------------------------------- */
    /* get the filename-base and path from the inputfile. */

    argv0 = argv[0];
    a = argv[1];
    p = strrchr(a, '\\');
    if (NULL == p)
        p = strrchr(a, '/');
    if (p)
        p++;
    else
        p = a;

    strcpy(basename, p);
    p = strrchr(basename, '.');
    if (p) *p = 0;

    /*--------------------------------------------- */
    /* read the input file */

    set_val("base", basename);
    lines = NULL;
    read_lines(argv[1], &lines);
    reverse_list(&lines);

    if (NULL == lines) return 1;

    /*--------------------------------------------- */
    /* check template for "<frameset" */

    make_template_name(tpl_file, get_val("template",  "tpl_simple.htm"), "");

    fp = fopen_config(tpl_file);
    if (fp)
    {
        while (fgets(line, sizeof line, fp))
        {
            strlwr(line);
            if (strstr(line, "<frameset"))
                { framed_mode = true; break; }
        }
        fclose(fp);
    }

    /*--------------------------------------------- */
    /* set "table of contents" mode */

    toc_mode = framed_mode ? TOC_LINES : TOC_PARA;
    tm = get_val("tocmode", NULL);
    if (tm)
    {
        if (0 == stricmp(tm, "para"))  toc_mode = TOC_PARA;
        if (0 == stricmp(tm, "list"))  toc_mode = TOC_LIST;
        if (0 == stricmp(tm, "lines")) toc_mode = TOC_LINES;
    }

    put_toc = true;

    cvt_amp = 0 != stricmp(get_val("cvt_amp", ""), "false");
    numbers = 0 == stricmp(get_val("numbers", ""), "true");
    no_escape = 0 == stricmp(get_val("escape", ""), "false");

    /*--------------------------------------------- */
    /* scan through lines to see what it all means */

    chapter_count = set_flags(lines);
    file_base = get_val("basename", basename);
    file_ext  = get_val("extension", ".htm");

    /*--------------------------------------------- */
    /* create output */

    if (framed_mode)
    {
        int n;
        const char *frame_template;

        frame_template = get_val("template",  "tpl_frame.htm");
        make_template_name(tpl_file,  frame_template, "");
        make_output_name(output_file, 0);
        copy_text(tpl_file, output_file, lines, 0);

        make_template_name(tpl_file,  frame_template, "_toc");
        make_output_name(output_file, -1);
        copy_text(tpl_file, output_file, lines, 0);

        n = 0;
        do {
            n++;
            /* set_auto_vars(lines, n); */
            make_template_name(tpl_file,  frame_template, "_body");
            make_output_name(output_file, n);
            copy_text(tpl_file, output_file, lines, n);

        } while (n < chapter_count);
    }
    else /* simple mode */
    {
        make_output_name(output_file, 0);
        if (fp)
            copy_text(tpl_file, output_file, lines, 0);
        else
            copy_text(NULL, output_file, lines, 0);
    }

    printf("done.\n");
    return 0;
}

/*----------------------------------------------------------------------------*/

